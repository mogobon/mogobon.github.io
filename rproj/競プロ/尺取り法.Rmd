---
title: "尺取り法"
author: "mogobon"
date: "最終更新: `r Sys.Date()`"
output:
  bookdown::html_document2:
    css: "style.css"
    mathjax: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    includes:
      in_header: "../mathjax_macros.js"
    code_download: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
    number_sections: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

:::{.note}

* この記事は, 筆者が数学と競プロを勉強するために書いたお遊びの記事です. 
* 筆者はトンチンカンな議論を展開しがちなので, そのような議論が含まれている可能性に注意してください.
* 私はそのような議論がなされることがないようにできる限り努めます. 
:::

# 適用する形式
* 列が与えられるので, 条件を満たす部分列をすべて利用して何らかの解を求めよ. 

# 例題

## [ABC032C 列](https://atcoder.jp/contests/abc032/tasks/abc032_c)

:::{.problem}
長さ$N$の整数列$S=(s_1,\cdots,s_N)$と整数$K$がある. 以下の条件を満たす$S$の連続部分列のうち, 最長のものを求めよ. 

* 部分列に含まれるすべての要素の値の積は$K$以下である.

条件を満たす部分列がひとつも存在しないときは, $0$を出力せよ.
:::

:::{.constraints}

**制約**

* $1\leq N\leq 10^5$
* $1\leq K\leq 10^5$
* $0\leq s_i\leq10^9~(1\leq i\leq N)$

:::

* 配列$S$に$0$が含まれている場合, すべての要素の総積は$0$になる.
* 要素すべてを含むような区間が最適になり, この場合答えは$N$になる. 
* すべての要素が正の場合を考える.

:::{.naive}
**愚直な方法**

* 左端を固定する.
  * 条件を満たす間右端を<font color="red">**左端から**</font>一つずつ右に動かしていく.
  * 満たさなくなったら答えを更新する.
* 左端を一つ右に動かして繰り返す.

:::

愚直な方法では, 

* 最悪の場合, 計算量が, あり得る区間(左端と右端)をすべて探索する方法と一致する.
* 計算量を改善する必要がある.


# 単調性

区間に対する単調性を定義する.

* 列$S$を$S=(s_0,s_1,\cdots s_{N-1})$とする. 
* $S$に含まれる連続部分列$(s_{l},s_{l+1}\cdots,s_{r-1})$を考える.
* $(s_{l},s_{l+1}\cdots,s_{r-1})$を区間$[l,r)$と呼ぶ. 


:::{.definition name="単調性"}
 区間$I$に対して定まる量$c(I)$が, 次の性質を満たすとき, $c$は 「(区間の長さに対して, )**単調性**を持つ」という.

<!--* 区間の長さが増えるほど, 量$c$も増える-->

* $I_1,I_2\subset S,~ I_1\subseteq I_2 \Longrightarrow c(I_1)\leq c(I_2)$

:::
* 本当はもうちょっと厳密に定義したい. 

<!--* 区間とは何か？$c(I)$についても厳密に定義しなければいけないと思っている. -->

* 例: $c(l,r)=s_l\times s_{l+1}\cdots \times s_{r-1}~~~(\textcolor{red}{s_i>0},i\in\{l,l+1,\cdots,r-1\})$, $c(l,r)=s_l+s_{l+1}+\cdots+s_{r-1}~~~(\textcolor{red}{s_i>0},i\in\{l,l+1,\cdots,r-1\})$

:::{.proposition}
$c$は区間の長さに対して単調な量である. 
区間の左端$l$に対して, $c(l,r)\leq M$を満たす最大の$r$を$r_{l}$とする. このとき, $r_{l}\geq r_{l-1}$である. 

:::

:::{.proof}
* $c(l,r)$を$c(L,R)$と表記する. 
* $c(L,R)\leq M$であるとき, 「$c(L,R)$は達成可能である」と呼ぶ.
* $[l,r_{l-1})\subset [l-1,r_{l-1})$が成り立つ.
* $c$の単調性より, $c(l,r_{l-1})\leq c(l-1,r_{l-1})\leq M$が成り立つので, $c(l,r_{l-1})$は達成可能である. 

<!--* また, $c(l,r_{l-1})\geq c(l,r_{l-1}-d)~~~(0<d<r_{l-1}-l+1)$ が成り立つ.-->

<!--最大値を達成したいのだから, わざわざ区間を縮小する必要はない-->

:::

:::{.note name="$c([l,r))$の略称表記について"}
* 以降, 断りなく, $c([l,r))$を$c(l,r)$と表記するものとする. 

:::

* 上の証明が意味するところは, $c(l,r_{l-1})\leq M$だし, $l$に対する右端$r_l$を$r_{l-1}$よりも左に動かしても$c$の値は小さくなるだけなので, $r_{l}\geq r_{l-1}$ だよね. ということである. 
* 上を認めると, $r_{l+1}$は$l+1$から探索しなくても, $r_{l}$からはじめれば十分である.

:::{.assumption name="尺取法が成立するための, 仮定"}

**仮定**

**A1**

* $c$は次の単調性を満たす. 
* 列$S=(s_0,s_1,\cdots,s_{N-1})$に含まれる任意の2つの区間$I_1,I_2$について, 

$$
I_1\subseteq I_{2} \Longrightarrow c(I_1)\leq c(I_2)
$$

**A2**

* 次の差分更新が高速に行える.

* $c(l,r)$と$s_{r+1}$から, $c(l,r+1)$の値が高速に計算できること. 
  * $c(l,r+1)=\mathrm{add}(c(l,r),s_{r+1})$
* $c(l,r)$と$s_{l}$から, $c(l+1,r)$の値が高速に計算できること. 
  * $c(l+1,r)=\mathrm{remove}(c(l,r),s_{l})$

:::

:::{.example name="仮定のA2を満たす例"}

* $(S,+),~S\subset\mathbb{R}$
* $(S,\times),~S\subset\mathbb{R}\setminus\{0\}$
* $(S,\triangle),~S\subset\mathbb{Z}_{}$, $x\triangle y$は$x$と$y$の排他的論理和($\mathrm{XOR}$)を表す.

以上の台集合$S$と, $S$上の二項演算$\oplus$の組$(S,\oplus)$は,次の性質を満たす. 

* (二項演算の効率性) $x,y\in S$として, 二項演算$x\oplus y$が高速(大体$O(1)$くらい)にできる.
* (結合律) $x,y\in S, ~(x\oplus y)\oplus z=x\oplus(y\oplus z)$
* (単位元) 単位元$e\in S$が存在する.
  * 単位元は, $x\in S$に対して, $x\oplus e = e\oplus x=x$を満たす.
* (逆元) 任意の$x\in S$に対する逆元$x^{-1}\in S$が存在する.
  * 単位元は, $x\in S$に対して, $x\oplus x^{-1} = x^{-1}\oplus x=e$を満たす.

<!--(単位元の必要性) 単位元が存在しなければ逆元が定義できないから, 単位元は必要である。-->
<!--逆(群構造をなすなら, 差分更新の効率性は成り立たない.(反:一般線形群など). 二項演算が高速にできるなら成り立つかもしれない
また, アーベル群でも良いかもしれないが, その必然性がまだ言えていない-->

* **補足**
  * 「差分計算ができるためには, 上を満たさなければならない」ということが言いたいわけではない.
  * 「上を満たせば, 差分計算が高速にできることを保証したい.」 ということである. 

* このもとで, 差分更新は次のように高速に行うことができる.

* $c(l,r+1)= \mathrm{add}(c(l,r),s_{r+1})$が高速に計算できることを示す.

* $c(l,r)=\displaystyle\bigoplus_{i=l}^{r}s_i$と表記する. 
* $c(l,r+1)$について, 次のように同値変形できる.

$$
c(l,r+1)=\bigoplus_{i=l}^{r}s_i
=\left(\bigoplus_{i=l}^{r-1}s_i\right) \oplus s_r
=c(l,r)\oplus s_r
$$

* 等号は結合律により成り立つ. 
* よって, $c(l,r+1)=c(l,r)\oplus s_{r}$が成り立つ.
* これは, $c(l,r+1)$が, $c(l,r)$と$s_{r}$を用いて, 陽に(かつそれは高速に)計算できる量であることを表している.

* $c(l,r+1)$は累積代入により, 求めることができることがわかる.
  * 例(組$(S,\times),~S\subset\mathbb{Z}\setminus\{0\}$の場合): `now *= s[r]` 
  
<!--右に伸ばすだけだったら, 可換律は不要-->

* $c(l+1,r)= \mathrm{remove}(c(l,r),s_{l})$が高速に計算できることを示す.



* $c(l+1,r)$について, 次のように同値変形できる.

<!--(より簡単な別証明)
* $c(l,r)=s_{l}\oplus c(l+1,r)$の左側から, $s_{l}^{-1}$を作用させて, $c(l+1,r)=s_{l}^{-1}\oplus c(l,r)$
だが, こちらは, 等式の変形$A=B\rightarrow A\oplus C=B\oplus C$を示していないので使いたくない. -->

$$
\begin{align*}
c(l+1,r)&=\bigoplus_{i=l+1}^{r-1}s_i\\
&=s_{l}^{-1}\oplus s_{l}\oplus\left(\bigoplus_{i=l+1}^{r-1}s_i\right)~~~(\because\text{結合律}, \text{逆元の存在})\\
&=s_{l}^{-1}\oplus \left(\bigoplus_{i=l}^{r-1}s_i\right)~~~(\because\text{結合律})\\
&=s_{l}^{-1}\oplus c(l,r)
\end{align*}
$$

* よって, $c(l+1,r)=s_{l}^{-1}\oplus c(l,r)$が成り立つ.
* これは, $c(l+1,r)$が, $c(l,r)$と$s_{l}$を用いて, 陽に(かつそれは高速に)計算できる量であることを表している.
* また, 組$(S,\oplus)$が, 可換律$x,y\in S, x\oplus y=y\oplus x$を満たしていれば, $c(l+1,r)$は累積代入により, 求めることができることがわかる.
    * 例(組$(S,\times),~S\subset \mathbb{Z}\setminus\{0\}$の場合): `now //= s[l]`
    

:::



上の仮定のもとで, 尺取り法が成り立つ.

:::{.method name="尺取り法"}

**尺取り法**


* 左端$l$を固定する.
  * 条件を満たす間$r$を一つずつ右に動かしていき, $r_{l}$を求める.
  * 満たさなくなったら, 答えを現在の答えと求めた$c(l,r_{l})$のうち, 最適な方に更新する.
* $c(l,r_{l})$と$s_{l}$から, $c(l+1,r_{l+1})$の初期値を求める.
* $l$を一つ右に動かして繰り返す.

<!-- 初期値を求めるステップについて: $l$を縮める分必要である. 2,行目の伸ばす過程で行えない. 
効率的に, 一定の繰り返しで更新できるように正規化しておくとも言える. -->
:::



* 繰り返し直前で区間が$[l,r_l)$から$[l+1,r_l)$に縮む.
* この縮んだ分について, 区間を伸ばし始める前に, $c(l+1,r_{l})$の初期値の更新処理が必要である. 
  * ここで, 仮定の$\mathrm{remove}$が必要である.
* 変数を`l`としたfor文を動かせば, $l$は一つ右に動くという処理を書く必要はなくなる.




---

* このブログは書きかけです。今後更新するかもしれないことをまとめています。
  * 同様に, $r$を固定する場合を記述したい. 
  * $s(I)$の定義と演算の範囲
  * 他の問題の例も試してミスの穴を埋めたい

---

# 参考にした本
* アルゴリズム実技検定 公式テキスト上級〜エキスパート編, 大槻兼資 著, マイナビ出版, 2023
