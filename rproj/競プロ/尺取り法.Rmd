---
title: "尺取法"
author: "mogobon"
date: "最終更新: `r Sys.Date()`"
output:
  bookdown::html_document2:
    css: "style.css"
    mathjax: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    includes:
      in_header: "../mathjax_macros.js"
    code_download: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
    number_sections: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 適用する形式
* 列が与えられるので, 条件を満たす部分列をすべて利用して何らかの解を求めよ. 

# 例

## [ABC032C 列](https://atcoder.jp/contests/abc032/tasks/abc032_c)

:::{.problem}
長さ$N$の整数列$S=(s_1,\cdots,s_N)$と整数$K$がある. 以下の条件を満たす$S$の連続部分列のうち, 最長のものを求めよ. 

* 部分列に含まれるすべての要素の値の積は$K$以下である.

条件を満たす部分列がひとつも存在しないときは, $0$を出力せよ.
:::

:::{.constraints}

**制約**

* $1\leq N\leq 10^5$
* $1\leq K\leq 10^5$
* $0\leq s_i\leq10^9~(1\leq i\leq N)$

:::

* 配列$S$に$0$が含まれている場合, すべての要素の総積は$0$になる.
* 要素すべてを含むような区間が最適になり, この場合答えは$N$になる. 
* すべての要素が正の場合を考える.

:::{.naive}
**愚直な方法**

* 左端を固定する.
  * 条件を満たす間右端を<font color="red">**左端から**</font>一つずつ右に動かしていく.
  * 満たさなくなったら答えを更新する.
* 左端を一つ右に動かして繰り返す.

:::

愚直な方法では, 

* 最悪の場合, あり得る区間(左端と右端)を探索する方法と一致する.
* 計算量改善にならない.

:::{.definition name="単調性"}
列$S$を$S=(0,1,\cdots N-1)$とする. $S$に含まれる連続部分列をなす区間$I=[l,r)$を考える.  区間$I$に対して定まる量$c(I)$が, 次の性質を満たすとき, $c$は 「(区間の長さに対して, )**単調性**を持つ」という.

<!--* 区間の長さが増えるほど, 量$c$も増える-->

* $I_1,I_2\subset S,~ I_1\subseteq I_2 \Longrightarrow c(I_1)\leq c(I_2)$

:::
* 本当はもうちょっと厳密に定義したい. 

<!--* 区間とは何か？$c(I)$についても厳密に定義しなければいけないと思っている. -->

* 例: $c(l,r)=s_l\times s_{l+1}\cdots \times s_{r-1}~~~(\textcolor{red}{s_i>0},i\in\{l,l+1,\cdots,r-1\})$, $c(l,r)=s_l+s_{l+1}+\cdots+s_{r-1}~~~(\textcolor{red}{s_i>0},i\in\{l,l+1,\cdots,r-1\})$

:::{.proposition}
$c$は区間の長さに対して単調な量である. 
区間の左端$l$に対して, $c(l,r)\leq M$を満たす最大の$r$を$r_{l}$とする. このとき, $r_{l}\geq r_{l-1}$である. 

:::

:::{.proof}
* $c(L,R)\leq M$であるとき, 「$c(L,R)$は達成可能である」と呼ぶ.
* $[l,r_{l-1})\subset [l-1,r_{l-1})$が成り立つ.
* $c$の単調性より, $c([l,r_{l-1}))\leq c([l-1,r_{l-1}))\leq M$が成り立つので, $c([l,r_{l-1}))$は達成可能である. 

<!--* また, $c(l,r_{l-1})\geq c(l,r_{l-1}-d)~~~(0<d<r_{l-1}-l+1)$ が成り立つ.-->

<!--最大値を達成したいのだから, わざわざ区間を縮小する必要はない-->

:::

* 上の証明が意味するところは, $c(l,r_{l-1})\leq M$だし, $l$に対する右端$r_l$を$r_{l-1}$よりも左に動かしても$c$の値は小さくなるだけなので, $r_{l}\geq r_{l-1}$ だよね. ということである. 
* 上を認めると, $r_{l+1}$は$l+1$から探索しなくても, $r_{l}$からはじめれば十分である.

:::{.assumption name="差分更新の効率性に関する仮定"}

**仮定**

次の差分更新が高速に行えること.

* $c([l,r))$と$s_{r+1}$から, $c([l,r+1))$の値が高速に計算できること. 
  * $c([l,r+1))=\mathrm{add}(c([l,r)),s_{r+1})$
* $c([l,r))$と$s_{l}$から, $c([l+1,r))$の値が高速に計算できること. 
  * $c([l+1,r))=\mathrm{remove}(c([l,r)),s_{l})$

:::

上の仮定のもとで, 尺取り法が成り立つ.

:::{.method name="尺取り法"}

**尺取り法**


* 左端$l$を固定する.
  * 条件を満たす間$r$を一つずつ右に動かしていき, $r_{l}$を求める.
  * 満たさなくなったら答えを更新する.
* $l$を縮める分, $c([l+1,r_{l}))$の初期値を更新する
* $l$を一つ右に動かして繰り返す.

:::


* 繰り返し直前で区間が$[l,r_l)$から$[l+1,r_l)$に縮む.
* この縮んだ分について, 区間を伸ばし始める前に, $c([l+1,r_{l}))$の初期値の更新処理が必要である. 
  * ここで, 仮定の$\mathrm{remove}$が必要である.
* 変数を`l`としたfor文を動かせば, $l$は一つ右に動くという処理を書く必要はなくなる.

---

* このブログは書きかけです。今後更新するかもしれないことをまとめています。
  * 同様に, $r$を固定する場合を記述したい. 
  * $s(I)$の定義と演算の範囲
  * 他の問題の例も試してミスの穴を埋めたい

---

# 参考にした本
* アルゴリズム実技検定 公式テキスト上級〜エキスパート編, 大槻兼資 著, マイナビ出版, 2023
