tags: [ABC参加記]
---
# ABC420振り返り

##  コンテスト結果

* ooo(2)--
* レート差分: 565(-9)

## A問題

### 問題概要

$X$月後の$Y$ヶ月後を求めよ。$(1\leq X,Y\leq12)$

- [問題リンク](https://atcoder.jp/contests/abc420/tasks/abc420_a)
### 考えたこと

* `l = [1,2,...,12]`を用意する。
* $X$月は`l[X-1]`である。
* 現在の値から`+Y`だけすればいい。
* ただし周期性があるので、要素の個数で割った時のあまりにする。
* 求める答えは、`l[(X-1+Y)%12]`


```python
l = [i for i in range(1,12+1)]
x,y = map(int,input().split())
print(l[(x-1 + y)%12])
```

[コンテスト時の提出コード](https://atcoder.jp/contests/abc420/submissions/68735026)


## B問題

* [問題リンク](https://atcoder.jp/contests/abc420/tasks/abc420_b)

### 考えたこと


* 誤読により行ごとに総和をとっていた。
* 二次元配列`a`に対して`zip(*a)`で転置を取れる。
* これにより、横持ちデータを縦持ちデータに書き換える。

```python
n,m=map(int,input().split())
s = []
for _ in range(n):
    a = list(input())
    a = list(map(int,a))
    s.append(a)
s = list(zip(*s))

p = [0]*n
for i in range(m):
    t = sum(s[i])
    if t >= (n+1)//2:
        for j in range(n):
            if s[i][j] == 0: p[j]+=1
    else:
        for j in range(n):
            if s[i][j] == 1: p[j]+=1

mx = max(p)
mxidx = []

for i in range(n):
    if p[i] == mx:mxidx.append(i+1)
print(*mxidx)
```

[コンテスト時の提出コード](https://atcoder.jp/contests/abc420/submissions/68744858)
  

## C問題

- [問題リンク](https://atcoder.jp/contests/abc420/tasks/abc420_c)

### 考えたこと
* $X_i,Y_i$だけ影響するので、そこだけ考えればいいということはすぐに思いつく。
* そこからの処理で**複雑な場合分け**を書いてしまい大失敗。
  * **定番の沼**
* 2ペナした後、全ての方針を捨てて、１から考え直した。
* 式変形にして差分を陽に書き出した。

### 式変形



* 書き換える前の配列: $A,\ B$
* 書き変わった後の配列: $A^{\prime},\ B^{\prime}$
* 「(新しいの式) - (現在の式) = (差分)」とする。
* （差分）が簡単に計算できれば、(新しいの式)を次のようにして、導出できる。
* 「(新しいの式) = (現在の式) + (差分)」

（差分）は次のように表せる。


$$
\begin{aligned}
 &\sum_{j=1}^{N}\min(A^{\prime}_j,B^{\prime}_j) - \sum_{j=1}^{N}\min(A_j,B_j) \\
=& \left(
    \min(A^{\prime}_i,B^{\prime}_i)
    + \sum_{\substack{j=1 \\ j\neq i}}^{N}\min(A_j,B_j)
\right)- \left(
    \min(A_i,B_i)
    + \sum_{\substack{j=1 \\ j\neq i}}^{N}\min(A_j,B_j)
\right) \\
=& \min(A^{\prime}_i,B^{\prime}_i)- \min(A_i,B_i)
\end{aligned}
$$



* 最終行は、更新前の$A_i,B_i$を保存しておけば、簡単に計算できる。
* 更新後の$A^{\prime}_i,B^{\prime}_i$はクエリで与えられる。
* よって、各クエリでこの（差分）は$O(1)$で計算できる。

```python
n,q=map(int,input().split())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
sm = 0
for i in range(n):
    if a[i] <= b[i]: sm += a[i]
    else: sm += b[i]

for _ in range(q):
    op,idx,x = input().split()
    idx = int(idx)-1
    v = int(x)
    olda,oldb = a[idx],b[idx]
    if op == "A": a[idx] = v
    else: b[idx] = v

    t1 = min(a[idx], b[idx])
    t2 = min(olda,oldb)
    res = t1 - t2
    sm += res
    print(sm)
```

[コンテスト時の提出コード](https://atcoder.jp/contests/abc420/submissions/68766081)

## 反省
* 前回から悪化している点
  * 焦りすぎた。
  * 若干体調管理もできていなくて、頭痛薬をぶち込んだがあんまり治らず、それゆえに余計焦ったのもある。
  * 前のめりになりすぎた。
  * D問題は「再帰全探索」だと思い込んでしまった。
    * ∵ 「数時間前に解いた問題に引っ張られがち」の悪癖による。
  * BFSの考察が生えなかったのは自分の中での知識不足な気がする。
    * 次のように考えればBFSが出たかもしれない。
      1. 「操作回数の最小値」
      2. 「移動回数の最小値」
      3. 「移動距離の最小化」
      4. 「最短距離」
* 今回良かった点
  * C問題で場合分けの方針を全部捨てたこと
    * もっと早く捨てたらなお良かった。50分強（+ペナ2）かかってるし。
  * `zip(*二次元配列)`を転置した`[(a_{*0}),(a_{*1}),...,(a_{*n})]`を適用できた。
    * 役にたつかはわからない。

