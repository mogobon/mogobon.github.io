---
title: "尺取法"
author: "mogobon"
date: "最終更新: `r Sys.Date()`"
output:
  bookdown::html_document2:
    css: "style.css"
    mathjax: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    includes:
      in_header: "../mathjax_macros.js"
    code_download: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
    number_sections: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 適用する形式
* 列が与えられるので, 条件を満たす部分列をすべて利用して何らかの解を求めよ. 

# 例

## [ABC032C 列](https://atcoder.jp/contests/abc032/tasks/abc032_c)

:::{.problem}
長さ$N$の整数列$S=(s_1,\cdots,s_N)$と整数$K$がある. 以下の条件を満たす$S$の連続部分列のうち, 最長のものを求めよ. 

* 部分列に含まれるすべての要素の値の積は$K$以下である.

条件を満たす部分列がひとつも存在しないときは, $0$を出力せよ.
:::

:::{.constraints}

**制約**

* $1\leq N\leq 10^5$
* $1\leq K\leq 10^5$
* $0\leq s_i\leq10^9~(1\leq i\leq N)$

:::

* 配列$S$に$0$が含まれている場合, すべての要素の総積は$0$になる.
* 要素すべてを含むような区間が最適になり, この場合答えは$N$になる. 
* すべての要素が正の場合を考える.

:::{.naive}
**愚直な方法**

* 左端を固定する.
  * 条件を満たす間右端を<font color="red">**左端から**</font>一つずつ右に動かしていく.
  * 満たさなくなったら答えを更新する.
* 左端を一つ右に動かして繰り返す.

:::

愚直な方法では, 

* 最悪の場合, あり得る区間(左端と右端)を探索する方法と一致する.
* 計算量改善にならない.

:::{.definition name="区間の長さに対する単調性"}
集合$S$を$S=\{0,1,\cdots N-1\}$とし, その部分集合である区間$I=[l,r)$を考える.  区間に対して, 定まる量$c(I)$が, 次の性質を満たすとき, $c$は 「区間に対して, **単調性**を持つ」という.

<!--* 区間の長さが増えるほど, 量$c$も増える-->

* $I_1,I_2\in S,~ I_1\subseteq I_2 \Longrightarrow c(I_1)\leq c(I_2)$

:::
* 本当はもうちょっと厳密に定義したい. 
* 例: $c(l,r)=\prod_{i=l}^{r-1}s_i$, $c(l,r)=\sum_{i=l}^{r-1}s_i$

:::{.proposition}
$c$は区間に対して単調な量である. 
区間の左端$l$に対して, $c(l,r)\leq M$を満たす最大の$r$を$r_{l}$とする. このとき, $r_{l}\geq r_{l-1}$である. 

:::

:::{.proof}
* $c(L,R)\leq M$であるとき, 「$c(L,R)$は達成可能である」と呼ぶ.
* $[l,r_{l-1})\subset [l-1,r_{l-1})$が成り立つ.
* $c$の単調性より, $c([l,r_{l-1}))\leq c([l-1,r_{l-1}))\leq M$が成り立つので, $c([l,r_{l-1}))$は達成可能である. 

<!--* また, $c(l,r_{l-1})\geq c(l,r_{l-1}-d)~~~(0<d<r_{l-1}-l+1)$ が成り立つ.-->

<!--最大値を達成したいのだから, わざわざ区間を縮小する必要はない-->

:::

* 上の証明が意味するところは, $c(l,r_{l-1})\leq M$だし, $l$に対する右端$r_l$を$r_{l-1}$よりも左に動かしても$c$の値は小さくなるだけなので, $r_{l}\geq r_{l-1}$ だよね. ということである. 
* 上を認めると, $r_{l}$は$l$から探索しなくても, $r_{l-1}$からはじめれば十分である.


:::{.method name="尺取り法"}

**尺取り法**


* 左端$l$を固定する.
  * 条件を満たす間$r$を一つずつ右に動かしていき, $r_{l}$を求める.
  * 満たさなくなったら答えを更新する.
* $l$を縮める分, $c([l+1,r_{l}))$の初期値に更新する
* $l$を一つ右に動かして繰り返す.

:::


* 繰り返し直前で区間が$[l,r_l)$から$[l+1,r_l)$に縮む.
* この縮んだ分について, $c([l+1,r_{l}))$の初期値の更新処理が必要である. 
* 変数を`l`としたfor文を動かせば, $l$は一つ右に動くという処理を書く必要はなくなる.


# 参考にした本
* アルゴリズム実技検定 公式テキスト上級〜エキスパート編, 大槻兼資 著, マイナビ出版, 2023
